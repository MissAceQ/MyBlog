<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />





<link href="/css/googlefont.css?v=5.0.1" rel="stylesheet" type="text/css" />




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="MissAceQ">
<meta property="og:url" content="https://MissAceQ.github.io/index.html">
<meta property="og:site_name" content="MissAceQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MissAceQ">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> MissAceQ </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-tw">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <!----------- add Fork me on Github ------------>
    
    
    
    <!----------- add Fork me on Github ------------> 

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">MissAceQ</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">现在永远是最好的时候</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首頁
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分類
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            歸檔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            標籤
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
    	
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/29/singleton/" itemprop="url">
                  23种设计模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-09-29T15:27:34+08:00" content="2016-09-29">
              2016-09-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/29/singleton/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/29/singleton/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="6个创建型："><a href="#6个创建型：" class="headerlink" title="6个创建型："></a>6个创建型：</h3><p><strong>简单工厂模式(SimpleFactory)</strong><br><strong>工厂方法模式(Factory Method)</strong><br><strong>抽象工厂模式(Abstract Factory)</strong><br><strong>单例模式(Singleton)</strong><br>原型模式(Prototype)<br>建造者模式(Builder)</p>
<h3 id="7个结构型模式"><a href="#7个结构型模式" class="headerlink" title="7个结构型模式"></a>7个结构型模式</h3><p><strong>适配器模式(Adapter)</strong><br>桥接模式(Bridge)<br>组合模式(Composite)<br><strong>装饰模式(Decorator)</strong><br>外观模式(Facade)<br>享元模式(Fly weight)<br>代理模式(Proxy)</p>
<h3 id="11个行为型模式"><a href="#11个行为型模式" class="headerlink" title="11个行为型模式"></a>11个行为型模式</h3><p>职责链模式(Chain of Responsibility)<br>命令模式(Command)<br>解释器模式(Interpreter)<br>迭代器模式(Iterator)<br>中介者模式(Mediator)<br>备忘录模式(Memento)<br><strong>观察者模式(Observer)</strong><br>状态模式(State)<br><strong>策略模式(Strategy)</strong><br><strong>访问者模式(Visitor)</strong><br>模板方法模式(Template Method)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

    
    <div class="ds-share flat" data-thread-key="2016/09/29/singleton/" data-title="23种设计模式" data-images="/" data-content="success share" data-url="/">
        <div class="ds-share-inline">
          <ul  class="ds-share-icons-16" style="margin-top: 30px">
            
            
            <li><span>分享到：</span></li>
            <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
            <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
            <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
            <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
            <li> <a class="ds-facebook flat" href="javascript:void(0);" data-service="facebook">Facebook</a> </li>
            <li> <a class="ds-twitter flat" href="javascript:void(0);" data-service="twitter">Twitter</a> </li>
            
          </ul>
          
        </div>
     </div>

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
    	
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/28/singleton/" itemprop="url">
                  简单工厂模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-09-28T16:52:01+08:00" content="2016-09-28">
              2016-09-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/28/singleton/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/28/singleton/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><blockquote>
<p>首先将需要创建的各种不同对象的相关代码封装到不同的类（<strong>具体产品类</strong>）中；<br>将它们公共的代码进行抽象和提取后封装在一个<strong>抽象产品类</strong>中，每一个具体产品类都是抽象产品类的子类；<br>然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数不同创建不同的具体产品对象；<br>客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。</p>
</blockquote>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>简单工厂模式(Simple Factory Pattern)：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式，它属于类<strong>创建型</strong>模式。</p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><p>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。简单工厂模式结构比较简单，其核心是工厂类的设计，结构图：</p>
<p><img src="http://o9j22gj41.bkt.clouddn.com/20160928_java_simplefactory.png" alt="简单工厂结构图"></p>
<ul>
<li>Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product。</li>
<li>Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。</li>
<li>ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。</li>
</ul>
<p>在简单工厂模式中，通过工厂类来创建一个产品类的实例，而<strong>无须使用new关键字</strong>来创建对象，它是工厂模式家族中最简单的一员。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="抽象产品类"><a href="#抽象产品类" class="headerlink" title="抽象产品类"></a>抽象产品类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;  </div><div class="line">     </div><div class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodSame</span><span class="params">()</span> </span>&#123;  <span class="comment">//所有产品类的公共业务方法</span></div><div class="line">       <span class="comment">//公共方法的实现  </span></div><div class="line">   	&#125;  </div><div class="line"></div><div class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span></span>;  <span class="comment">//声明抽象业务方法 </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="具体产品类"><a href="#具体产品类" class="headerlink" title="具体产品类"></a>具体产品类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;  </div><div class="line">    </div><div class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span> </span>&#123;  <span class="comment">//实现业务方法 </span></div><div class="line">       <span class="comment">//业务方法的实现  </span></div><div class="line">   	&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="工厂类-核心"><a href="#工厂类-核心" class="headerlink" title="工厂类(核心)"></a>工厂类(核心)</h4><p>在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入的参数不同可以创建不同的产品对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;  </div><div class="line">   </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">getProduct</span><span class="params">(String arg)</span> </span>&#123;  <span class="comment">//静态工厂方法  </span></div><div class="line">        Product product = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">"A"</span>)) &#123;  </div><div class="line">            product = <span class="keyword">new</span> ConcreteProductA();  </div><div class="line">            <span class="comment">//初始化设置product  </span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg.equalsIgnoreCase(<span class="string">"B"</span>)) &#123;  </div><div class="line">            product = <span class="keyword">new</span> ConcreteProductB();  </div><div class="line">            <span class="comment">//初始化设置product  </span></div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> product;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="典型代码"><a href="#典型代码" class="headerlink" title="典型代码"></a>典型代码</h4><p>在客户端代码中，通过调用工厂类的工厂方法即可得到产品对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;  </div><div class="line">        Product product;   </div><div class="line">        product = Factory.getProduct(<span class="string">"A"</span>); <span class="comment">//通过工厂类创建产品对象  </span></div><div class="line">        product.methodSame();  </div><div class="line">        product.methodDiff();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

    
    <div class="ds-share flat" data-thread-key="2016/09/28/singleton/" data-title="简单工厂模式" data-images="/" data-content="success share" data-url="/">
        <div class="ds-share-inline">
          <ul  class="ds-share-icons-16" style="margin-top: 30px">
            
            
            <li><span>分享到：</span></li>
            <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
            <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
            <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
            <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
            <li> <a class="ds-facebook flat" href="javascript:void(0);" data-service="facebook">Facebook</a> </li>
            <li> <a class="ds-twitter flat" href="javascript:void(0);" data-service="twitter">Twitter</a> </li>
            
          </ul>
          
        </div>
     </div>

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
    	
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/23/singleton/" itemprop="url">
                  单例模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-09-23T11:04:50+08:00" content="2016-09-23">
              2016-09-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/23/singleton/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/23/singleton/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><hr>
<h3 id="目的要点"><a href="#目的要点" class="headerlink" title="目的要点"></a>目的要点</h3><ol>
<li>创建对象，确保对象的唯一性。在同一个系统里，对象只有一个实例。</li>
<li>由类自己保存它的唯一实例。</li>
<li>提供一个访问实例的方法</li>
</ol>
<h3 id="实现分类"><a href="#实现分类" class="headerlink" title="实现分类"></a>实现分类</h3><ul>
<li>饿汉式</li>
<li>懒汉式</li>
<li>双重检查锁</li>
<li>静态内部类实现（饿汉式+懒汉式）</li>
<li>枚举式</li>
</ul>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><ol>
<li>在定义静态变量的时候就实例化了单例类。</li>
<li>在类加载的时候，静态方法会先加载，所以单例对象在类加载的时候九被创建了，<strong>静态变量只加载一次，可以保证单例对象的唯一性</strong>，并且是线程安全的。</li>
<li>但是在类加载的时候就创建，会影响程序的效率。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">	<span class="comment">//唯一实例</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">	<span class="comment">//只能由类自己创建实例</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//提供一个全局访问的方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">	<span class="comment">//唯一实例</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="comment">//只能由类自己创建实例</span></div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//提供一个全局访问的方法</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">			instance = <span class="keyword">new</span> Singleton();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> instance;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>懒汉式在需要的时候才实例化，在类加载的时候不进行实例化，能起到懒加载的作用。</li>
<li>但是如果在多线程的情况下，比如线程Ａ和线程Ｂ同时调用getInstance()，可能会导致<strong>并发问题</strong>。</li>
<li>所以要在getInstance()前加上synchronized进行同步，但是这样每次都要判断，会降低访问速度。</li>
<li>可以用双重检查锁。  </li>
</ol>
<h3 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h3><p>双重检查锁的第一次检查是检查实例是否存在，如果不存在再进入下面的同步块，而不是直接进入同步块．第二重检查是进入同步块后，再检查实例是否存在，如果不存在，就在同步的情况下创景实例．</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</div><div class="line">	  <span class="comment">//对保存实例的变量添加volitile的修饰</span></div><div class="line">	  <span class="comment">//唯一实例</span></div><div class="line">	  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	  <span class="comment">//只能由类自己负责创建实例</span></div><div class="line">	  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	  &#125;</div><div class="line"></div><div class="line">	  <span class="comment">//外部访问实例的方法</span></div><div class="line">	  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">	    <span class="comment">//第一重检查，检查实例是否存在，如果不存在，再进入同步代码块.</span></div><div class="line">	    <span class="comment">//存在未初始化过，多个线程都发现实例不存在而进入if语句</span></div><div class="line">	    <span class="keyword">if</span> (<span class="class"><span class="keyword">interface</span>  </span>== <span class="keyword">null</span>)</div><div class="line">	        <span class="comment">//锁定代码块，锁定代码块保证了，if语句中创建实例的语句只能由一个线程执行</span></div><div class="line">	        <span class="keyword">synchronized</span> (Singleton.class)｛</div><div class="line">	          <span class="comment">//第二重检查，避免第一重检查中同时进入的线程，在其中一个进入锁定代码块创建单例而退出时，其他依然会进入锁定代码块创建实例的情况</span></div><div class="line"></div><div class="line">	          <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">	                instance = <span class="keyword">new</span> Singleton();<span class="comment">//创建单例实例</span></div><div class="line">	          &#125;</div><div class="line">	        ｝</div><div class="line">	    &#125;</div><div class="line">	    <span class="keyword">return</span> instance;</div><div class="line">	  &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="静态内部类实现（饿汉式-懒汉式）"><a href="#静态内部类实现（饿汉式-懒汉式）" class="headerlink" title="静态内部类实现（饿汉式+懒汉式）"></a>静态内部类实现（饿汉式+懒汉式）</h3><p>饿汉单例模式在类加载的时候就会创建，不能实现延时加载，如果以后不用，还会占据内存，还会影响程序的加载效率．懒汉单例模式需确保线程安全，性能会受到影响．比较好的实现方式是结合二者的优点，使用静态内部类来实现单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 类级的内部类，也就是静态类的成员式内部类，</div><div class="line">     * 该内部类的实例与外部类的实例没有绑定关系，而且只有被调用时才会装载，从而实现了延迟加载</div><div class="line">     */</div><div class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 静态初始化器，由JVM来保证线程安全</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 私有化构造方法</div><div class="line">     * 只能由类自己负责创建实例</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//对外提供获取实例的静态方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="枚举式"><a href="#枚举式" class="headerlink" title="枚举式"></a>枚举式</h3><p>单元素的枚举类型已经成为实现Singleton的最佳方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 定义一个枚举的元素，它就代表了Singleton的一个实例</div><div class="line">     */</div><div class="line">    uniqueInstance;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 单例的方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//功能树立</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li>任务管理器</li>
<li>回收站</li>
<li>网站的计数器</li>
<li>数据库连接池的设计一般也采用单例模式</li>
<li>多线程的连接池，为了方便线程池对池中线程进行控制</li>
<li>操作系统的文件系统，一个操作系统只能有一个文件系统</li>
</ol>
<p>总结：<br>（1）资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。<br>（2）控制资源的情况下，方便资源之间的互相通信。如线程池等。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

    
    <div class="ds-share flat" data-thread-key="2016/09/23/singleton/" data-title="单例模式" data-images="/" data-content="success share" data-url="/">
        <div class="ds-share-inline">
          <ul  class="ds-share-icons-16" style="margin-top: 30px">
            
            
            <li><span>分享到：</span></li>
            <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
            <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
            <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
            <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
            <li> <a class="ds-facebook flat" href="javascript:void(0);" data-service="facebook">Facebook</a> </li>
            <li> <a class="ds-twitter flat" href="javascript:void(0);" data-service="twitter">Twitter</a> </li>
            
          </ul>
          
        </div>
     </div>

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
    	
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/09/21/slider/" itemprop="url">
                  轮播图
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-09-21T17:19:54+08:00" content="2016-09-21">
              2016-09-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/js小程序/" itemprop="url" rel="index">
                    <span itemprop="name">js小程序</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/21/slider/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/21/slider/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h3><hr>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将图片设为左浮动，利用jQuery的<strong>animate</strong>函数，实现向左滑动，再用<strong>setInterval</strong>定时循环执行。</p>
<h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ol>
<li>给容器设置overflow:hidden十分重要</li>
<li>点击小圆点时，一定要清除上一次的定时器，重新开始定时器时，要给intervalID重新赋值</li>
<li>imagebox的宽度要和image的宽度相等，否则循环显示时，就会出现box中有一大一小两张图片</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"showbox"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"imagebox"</span>&gt;</span> //放置图片</div><div class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image/1.jpg"</span> <span class="attr">alt</span>=<span class="string">"1.jpg"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image/2.jpg"</span> <span class="attr">alt</span>=<span class="string">"2.jpg"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image/3.jpg"</span> <span class="attr">alt</span>=<span class="string">"3.jpg"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image/4.jpg"</span> <span class="attr">alt</span>=<span class="string">"4.jpg"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"icobox"</span>&gt;</span> //放置图标</div><div class="line">        <span class="tag">&lt;<span class="name">pan</span> <span class="attr">rel</span>=<span class="string">"0"</span> <span class="attr">class</span>=<span class="string">"active"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">rel</span>=<span class="string">"1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">rel</span>=<span class="string">"2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">rel</span>=<span class="string">"3"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">.showbox &#123;</div><div class="line">	position: relative;</div><div class="line">	height: 300px;</div><div class="line">	width: 570px;</div><div class="line">	overflow: hiden;   // 关键</div><div class="line">	border: 10px solid #eee;</div><div class="line">	background-color: #eee;</div><div class="line">	border-radius: 10px;</div><div class="line">	-webkit-border-radius:10px;</div><div class="line">    -moz-border-radius:10px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.imagebox &#123;</div><div class="line">	position: relative;</div><div class="line">	height: 270px;</div><div class="line">	width: 570px;   //宽度与img的一致</div><div class="line">	top: 0;</div><div class="line">	left: 5px;</div><div class="line">	overflow: hiden;   // 关键</div><div class="line">&#125;</div><div class="line"></div><div class="line">.imagebox img &#123;</div><div class="line">	display: block;</div><div class="line">	width: 570px;   // 宽度与imagebox的一致</div><div class="line">	height: 270px;</div><div class="line">	float: left;   //设置为左浮动</div><div class="line">&#125;</div><div class="line"></div><div class="line">.iconbox &#123;</div><div class="line">	position: absolute;</div><div class="line">	border: none;</div><div class="line">	width: 120px;</div><div class="line">	height: 12px;</div><div class="line">	left: 220px;</div><div class="line">	bottom: 10px;</div><div class="line">	text-align: center;</div><div class="line">	line-height: 40px;</div><div class="line">	overflow: hiden;   // 关键</div><div class="line">&#125;</div><div class="line"></div><div class="line">.iconbox span &#123;</div><div class="line">	background: url("../imag/.png") 0 0 no-repeat; //css sprite实现变色</div><div class="line">	width: 12px;</div><div class="line">	height: 12px;</div><div class="line">	cursor: pointer;</div><div class="line">	float: left;</div><div class="line">	margin-left: 3px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.icobox span.active&#123;</div><div class="line">    background: url("../image/ico.png") 0px -12px no-repeat; //css sprite实现变色</div><div class="line">    cursor: default;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> imagebox=$(<span class="string">".showbox"</span>).children(<span class="string">'.imagebox'</span>)[<span class="number">0</span>],<span class="comment">//获得图片容器</span></div><div class="line">        icobox=$(<span class="string">".showbox"</span>).children(<span class="string">'.icobox'</span>)[<span class="number">0</span>],<span class="comment">//获得图标容器</span></div><div class="line">        ico=$(icobox).children(<span class="string">'span'</span>),<span class="comment">//获得图标数组</span></div><div class="line">        imagenum=$(imagebox).children().size(),<span class="comment">//获得图片数量</span></div><div class="line">        imageboxWidth=$(imagebox).width(),<span class="comment">//获得图片容器的宽度</span></div><div class="line">        imagewidth=imageboxWidth*imagenum,<span class="comment">//获得图片的总宽度</span></div><div class="line">        activeID = <span class="built_in">parseInt</span>($($(icobox).children(<span class="string">".active"</span>)[<span class="number">0</span>] ).attr(<span class="string">"rel"</span>)),<span class="comment">//获得激活的图标ID</span></div><div class="line">        nextID=<span class="number">0</span>,<span class="comment">//下一个图标的ID</span></div><div class="line">        intervalID,<span class="comment">//setInterval()函数的ID</span></div><div class="line">        delaytime=<span class="number">4000</span>,<span class="comment">//延迟的时间</span></div><div class="line">        speed=<span class="number">700</span>;<span class="comment">//执行速度</span></div><div class="line">        $(imagebox).css(&#123;<span class="string">'width'</span> : imagewidth + <span class="string">"px"</span>&#125;);<span class="comment">//将图片容器的宽度设置为图片总宽度</span></div><div class="line"></div><div class="line">        <span class="keyword">var</span> rotate=<span class="function"><span class="keyword">function</span>(<span class="params">clickID</span>) </span>&#123; <span class="comment">//图片滑动函数</span></div><div class="line">            <span class="keyword">if</span> (clickID+<span class="number">1</span>)&#123; <span class="comment">//有下一张图片</span></div><div class="line">                nextID=clickID;</div><div class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//没有下一张则从头开始</span></div><div class="line">                nextID=(activeID+<span class="number">1</span>)%<span class="number">4</span>;</div><div class="line">            &#125;;</div><div class="line">            $(ico[activeID]).removeClass(<span class="string">'active'</span>);</div><div class="line">            $(ico[nextID]).addClass(<span class="string">'active'</span>);</div><div class="line">            $(imagebox).animate(&#123;left:<span class="string">"-"</span>+nextID*imageboxWidth+<span class="string">"px"</span>&#125;, speed);<span class="comment">//jQuery中的animate函数</span></div><div class="line">            activeID=nextID;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        intervalID=setInterval(rotate,delaytime);<span class="comment">//循环函数</span></div><div class="line"></div><div class="line">        $.each(ico, <span class="function"><span class="keyword">function</span>(<span class="params">index, val</span>) </span>&#123;</div><div class="line">            $(<span class="keyword">this</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">                clearInterval(intervalID);<span class="comment">//清楚之前的定时任务（关键！！！）</span></div><div class="line">                 <span class="keyword">var</span> clickID = index;   <span class="comment">// （关键！！！）</span></div><div class="line">                 rotate(clickID);<span class="comment">//运行一次带参数的rotate函数</span></div><div class="line">                 intervalID = setInterval(rotate,delaytime);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

    
    <div class="ds-share flat" data-thread-key="2016/09/21/slider/" data-title="轮播图" data-images="/" data-content="success share" data-url="/">
        <div class="ds-share-inline">
          <ul  class="ds-share-icons-16" style="margin-top: 30px">
            
            
            <li><span>分享到：</span></li>
            <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
            <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
            <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
            <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
            <li> <a class="ds-facebook flat" href="javascript:void(0);" data-service="facebook">Facebook</a> </li>
            <li> <a class="ds-twitter flat" href="javascript:void(0);" data-service="twitter">Twitter</a> </li>
            
          </ul>
          
        </div>
     </div>

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
    	
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/29/httpStatusCode/" itemprop="url">
                  HTTP状态码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-08-29T15:21:03+08:00" content="2016-08-29">
              2016-08-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HTTP/" itemprop="url" rel="index">
                    <span itemprop="name">HTTP</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/HTTP/面经/" itemprop="url" rel="index">
                    <span itemprop="name">面经</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/29/httpStatusCode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/29/httpStatusCode/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>http状态码总共分成5种类型：</p>
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">状态信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1**</td>
<td style="text-align:center">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td style="text-align:center">2**</td>
<td style="text-align:center">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td style="text-align:center">3**</td>
<td style="text-align:center">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td style="text-align:center">4**</td>
<td style="text-align:center">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td style="text-align:center">5**</td>
<td style="text-align:center">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<h3 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h3><ul>
<li>200：成功。</li>
<li>301：永久移动。</li>
<li>302：临时移动。</li>
<li>400：客户发送的请求不能理解。</li>
<li>403：fobidden。无权限，资源不可用，服务器拒绝提供服务。</li>
<li>404：not found，没找到资源。</li>
<li>500：服务器内部错误。<br>-说 503：服务暂不可用。</li>
</ul>
<h3 id="1-继续请求"><a href="#1-继续请求" class="headerlink" title="1** 继续请求"></a>1** 继续请求</h3><table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">状态信息</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">100</td>
<td style="text-align:center">continue</td>
<td style="text-align:center">继续。初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">101</td>
<td style="text-align:center">Switching Protocols</td>
<td style="text-align:center">服务器将遵从客户的请求转换到另外一种协议。（HTTP 1.1新）</td>
</tr>
</tbody>
</table>
<h3 id="2-成功"><a href="#2-成功" class="headerlink" title="2** 成功"></a>2** 成功</h3><table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">状态信息</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>200</strong></td>
<td style="text-align:center"><strong>OK</strong></td>
<td style="text-align:center">继续。初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">201</td>
<td style="text-align:center">Created</td>
<td style="text-align:center">服务器已创建。成功请求并创建了新的资源，Location头给出了它的URL。</td>
</tr>
<tr>
<td style="text-align:center">202</td>
<td style="text-align:center">Accepted</td>
<td style="text-align:center">已接受。已经接受请求，但未处理完成。</td>
</tr>
<tr>
<td style="text-align:center">203</td>
<td style="text-align:center">Non-Authoritative Information</td>
<td style="text-align:center">非授权信息。请求成功，但返回的meta信息不在原始的服务器(一些应答头可能不正确)，因为使用的是文档的副本。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">204</td>
<td style="text-align:center">No Content</td>
<td style="text-align:center">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</td>
</tr>
<tr>
<td style="text-align:center">205</td>
<td style="text-align:center">Reset Content</td>
<td style="text-align:center">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码强制浏览器清除表单输入内容。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">206</td>
<td style="text-align:center">Partial Content</td>
<td style="text-align:center">部分内容。服务器成功处理了部分GET请求，客户发送了一个带有Range头的GET请求，服务器完成了它。（HTTP 1.1新）</td>
</tr>
</tbody>
</table>
<h3 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3** 重定向"></a>3** 重定向</h3><table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">状态信息</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">300</td>
<td style="text-align:center">Multiple Choices</td>
<td>多种选择。客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。</td>
</tr>
<tr>
<td style="text-align:center"><strong>301</strong></td>
<td style="text-align:center">Moved Permanently</td>
<td><strong>永久移动</strong>。请求的资源已被永久的移动到新URL，新的URL在返回信息的Location头中给出，浏览器会自动定向到新URL，今后任何新的请求都应使用新的URL代替。</td>
</tr>
<tr>
<td style="text-align:center"><strong>302</strong></td>
<td style="text-align:center">Found</td>
<td><strong>临时移动</strong>。资源只是临时被移动。客户端应继续使用原有URL。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求<a href="http://host/~user（缺少了后面的斜杠），有的服务器" target="_blank" rel="external">http://host/~user（缺少了后面的斜杠），有的服务器</a> 返回301，有的则返回302。严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。</td>
</tr>
<tr>
<td style="text-align:center">303</td>
<td style="text-align:center">See Other</td>
<td>查看其它地址。与301类似。不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center"><strong>304</strong></td>
<td style="text-align:center"><strong>Not Modified</strong></td>
<td><strong>未修改</strong>。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档），指出客户端希望只返回在指定日期之后修改的资源。服务器告诉客户，原来缓冲的文档还可以继续使用。</td>
</tr>
<tr>
<td style="text-align:center">305</td>
<td style="text-align:center">Use Proxy</td>
<td>使用代理。客户请求的文档应该通过Location头所指明的代理服务器提取。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">306</td>
<td style="text-align:center">Unused</td>
<td>已经被废弃的HTTP状态码。</td>
</tr>
<tr>
<td style="text-align:center">307</td>
<td style="text-align:center">Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。（HTTP 1.1新）</td>
</tr>
</tbody>
</table>
<h3 id="4-客户端错误"><a href="#4-客户端错误" class="headerlink" title="4** 客户端错误"></a>4** 客户端错误</h3><table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">状态信息</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>400</strong></td>
<td style="text-align:center">Bad Request</td>
<td>客户端请求的<strong>语法错误</strong>，服务器无法理解。</td>
</tr>
<tr>
<td style="text-align:center">401</td>
<td style="text-align:center">Unauthorized</td>
<td>请求要求用户的身份认证。客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。</td>
</tr>
<tr>
<td style="text-align:center">402</td>
<td style="text-align:center">Payment Required</td>
<td>保留，将来使用。</td>
</tr>
<tr>
<td style="text-align:center"><strong>403</strong></td>
<td style="text-align:center">Forbidden</td>
<td><strong>资源不可用</strong>。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的<strong>权限设置导致</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><strong>404</strong></td>
<td style="text-align:center"><strong>Not Found</strong></td>
<td>服务器无法根据客户端的请求找到资源（网页）。</td>
</tr>
<tr>
<td style="text-align:center">405</td>
<td style="text-align:center">Method Not Allowed</td>
<td>请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">406</td>
<td style="text-align:center">Not Acceptable</td>
<td>指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">407</td>
<td style="text-align:center">Proxy Authentication Required</td>
<td>请求要求代理的身份认证，类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">408</td>
<td style="text-align:center">Request Time-out</td>
<td>服务器等待客户端发送的请求时间过长，超时。在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">409</td>
<td style="text-align:center">Conflict</td>
<td>通常和PUT请求有关，服务器完成客户端的PUT请求时可能返回此代码，由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">410</td>
<td style="text-align:center">Gone</td>
<td>客户端请求的资源已经不存在，服务器不知道应该重定向到哪一个地址。410不同于404，如果资源以前有现在被永久删除了可使用410代码，而 404表示由于未知的原因文档不可用。网站设计人员可通过301代码指定资源的新位置。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">411</td>
<td style="text-align:center">Length Required</td>
<td>服务器无法处理客户端发送的不带Content-Length的请求信息。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">412</td>
<td style="text-align:center">Precondition Failed</td>
<td>客户端请求头中的先决条件错误。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">413</td>
<td style="text-align:center">Request Entity Too Large</td>
<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After头的响应信息。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">414</td>
<td style="text-align:center">Request-URI Too Large</td>
<td>请求的URI过长（URI通常为网址），服务器无法处理。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">415</td>
<td style="text-align:center">Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式。</td>
</tr>
<tr>
<td style="text-align:center">416</td>
<td style="text-align:center">Requested range not satisfiable</td>
<td>服务器不能满足客户端在请求中指定的Range头。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">417</td>
<td style="text-align:center">Expectation Failed</td>
<td>服务器无法满足Expect的请求头信息。</td>
</tr>
</tbody>
</table>
<h3 id="5-服务器错误"><a href="#5-服务器错误" class="headerlink" title="5** 服务器错误"></a>5** 服务器错误</h3><table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">状态信息</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>500</strong></td>
<td style="text-align:center">Internal Server Error</td>
<td><strong>服务器内部错误</strong>，无法完成请求。</td>
</tr>
<tr>
<td style="text-align:center">501</td>
<td style="text-align:center">Not Implemented</td>
<td>服务器不支持服务器内部错误，无法完成请求。实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。</td>
</tr>
<tr>
<td style="text-align:center">502</td>
<td style="text-align:center">Bad Gateway</td>
<td>充当网关或代理的服务器，从远端服务器接收到了一个无效的请求。</td>
</tr>
<tr>
<td style="text-align:center"><strong>503</strong></td>
<td style="text-align:center">Service Unavailable</td>
<td><strong>服务暂不可用</strong>。由于负载过重或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中。</td>
</tr>
<tr>
<td style="text-align:center">504</td>
<td style="text-align:center">Gateway Time-out</td>
<td>充当代理或网关的服务器，表示不能及时地从远程服务器获得应答。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:center">505</td>
<td style="text-align:center">HTTP Version not supported</td>
<td>服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新）</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

    
    <div class="ds-share flat" data-thread-key="2016/08/29/httpStatusCode/" data-title="HTTP状态码" data-images="/" data-content="success share" data-url="/">
        <div class="ds-share-inline">
          <ul  class="ds-share-icons-16" style="margin-top: 30px">
            
            
            <li><span>分享到：</span></li>
            <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
            <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
            <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
            <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
            <li> <a class="ds-facebook flat" href="javascript:void(0);" data-service="facebook">Facebook</a> </li>
            <li> <a class="ds-twitter flat" href="javascript:void(0);" data-service="twitter">Twitter</a> </li>
            
          </ul>
          
        </div>
     </div>

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
    	
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/25/dataType/" itemprop="url">
                  数据类型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-08-25T15:19:28+08:00" content="2016-08-25">
              2016-08-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/js基础/" itemprop="url" rel="index">
                    <span itemprop="name">js基础</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/js基础/面经/" itemprop="url" rel="index">
                    <span itemprop="name">面经</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/25/dataType/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/25/dataType/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>面试常遇到的问题之一，js基本数据类型有哪几种，每次都回答五种，但是其实ES6中新增了一种。。。还有关于Null和undefined的具体考察。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li><strong>Symbol</strong> (ES6新定义的)</li>
<li>Object</li>
</ol>
<p>前六种是原始类型，就是基本类型，再加一种更复杂的Object类型。</p>
<h3 id="Null和Undefined的区别"><a href="#Null和Undefined的区别" class="headerlink" title="Null和Undefined的区别"></a>Null和Undefined的区别</h3><h4 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h4><p>表示本来应该有，但是没有，代表了一个不存在的值(non-existence of a value)。</p>
<ol>
<li>声明变量时<strong>没有定义初始值</strong>，就有一个默认值Undefined。  </li>
<li>当试图<strong>访问一个不存在的对象</strong>属性或数组项时，返回一个undefined值。  </li>
<li>如果<strong>省略了函数的返回语句</strong>,返回undefined。  </li>
<li><strong>函数调用时未提供的值</strong>结果将为undefined参数值。  </li>
<li>void操作符也可以返回一个undefined值。像Underscore的库使用它作为一个防御式的类型检查，因为它是不可变的，可以在任何上下文依赖返回undefined。  </li>
<li>undefined是一个预定义的全局变量(不像null关键字)初始化为undefined值。</li>
</ol>
<h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><p>值Null是一个JS字面量，表示空值(null or an “empty” value)，没有对象被3呈现(no object is present)。通常用作一个空引用一个空对象的预期,就像一个占位符。</p>
<ol>
<li>DOM，它是独立于语言的，不属于ECMAScript规范的范围。因为它是一个外部API，试图获取一个不存在的元素返回一个null值，而不是undefined。  </li>
<li>如果需要给一个变量/属性指定一个不变值，将它传递给一个函数，或者从一个函数返回null(<strong>函数返回null，也算有返回值</strong>)，null几乎总是最好的选择。</li>
<li>通过分配null值，有效地清除引用，并假设对象没有引用其他代码，指定垃圾收集，确保回收内存。  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">s</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.num = num;</div><div class="line">	sayNum: <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">		alert(num);</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> sayNum;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么执行以下代码以后，结果如何？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> s(<span class="number">0</span>); <span class="comment">// 返回一个function</span></div><div class="line"><span class="keyword">var</span> s1 = s(<span class="number">1</span>); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>实际上，因为s所代表的function并没有return，但是s1已经声明，所以s1的结果是undefined。</p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>整数可以通过十进制、八进制、十六进制的字面值表示</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> intNum = <span class="number">55</span>; <span class="comment">// 十进制</span></div><div class="line"><span class="keyword">var</span> octalNum = <span class="number">070</span>; <span class="comment">// 八进制，第一位必须为0，解析成56</span></div><div class="line"><span class="keyword">var</span> octalNum = <span class="number">079</span>; <span class="comment">// 无效，9超过了8，解析成79</span></div><div class="line"><span class="keyword">var</span> hexNum = <span class="number">0xA</span>; <span class="comment">// 十六进制，前两位必须是0x，解析成10</span></div></pre></td></tr></table></figure>
<h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><ol>
<li>数值必须包含一个小数点，小数点后面必须有一个数字，如果小数点后面只有0，这个小数会被转化成整数。  </li>
<li>浮点数占用的内存空间是整数的两倍。  </li>
<li>对极大极小的浮点数用e表示法。  </li>
</ol>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><ol>
<li>0/0返回NaN（其他数除以0返回Infinity）。</li>
<li>任何涉及到NaN的操作都会返回NaN，比如 NaN==NaN 会返回false，但是ES6通过Object.is修正了这个问题，Object.is(NaN,NaN) 返回true。</li>
<li>isNaN()，这个函数可以用来判断参数是否“不是数值”，涉及到数值转换问题。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">isNaN</span>(<span class="string">"10"</span>); <span class="comment">// 返回true，字符串“10”可以转换成数值10。  </span></div><div class="line"><span class="built_in">isNaN</span>(<span class="string">"blue"</span>); <span class="comment">// 返回false，字符串“blue”无法转换成数值，所以返回false。</span></div></pre></td></tr></table></figure>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>除了Null和Undefined，每个值都有这个方法。一般使用的时候不需要传递参数，调用数值的toString()方法的时候，可以传递基数，默认是10，代表十进制。</p>
<h4 id="String-1"><a href="#String-1" class="headerlink" title="String()"></a>String()</h4><p>这个函数可以将任何类型的值转换成字符串，包括Null转换成”null”，undefined转换成”undefined”。</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>Boolean类型只有两个值：true和false。</p>
<h4 id="Boolean-1"><a href="#Boolean-1" class="headerlink" title="Boolean()"></a>Boolean()</h4><p>这个函数可以将其他类型的值转换成为布尔类型。</p>
<h4 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h4><ol>
<li>false：””(空字符串)、0、null、undefined</li>
<li>true：非空字符串、非零数字值、任何对象、(undefined不适用)</li>
</ol>
<h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><p>Symbol，表示独一无二的值。</p>
<p>Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">typeof</span> s; <span class="comment">// "Symbol"</span></div></pre></td></tr></table></figure>
<p>Symbol函数<strong>不能使用new命令</strong>，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<p>Symbol函数可以接受一个字符串作为参数，Symbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 没有参数的情况</span></div><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>();</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>();</div><div class="line"></div><div class="line">s1 === s2; <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// 有参数的情况</span></div><div class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</div><div class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</div><div class="line"></div><div class="line">s1 === s2; <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>Symbol值不能与其他类型的值进行运算，但是，Symbol值可以显式转为字符串，也可以转为布尔值，但是不能转为数值。</p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ol>
<li>这个类型实例化的对象，实际上是一组数据和function的集合。  </li>
<li>实例化对象的过程有两种，一种是通过new操作符，一种是通过对象字面量表示法。</li>
<li>可以在Object类型基础上继承出更多的类型，Array、function、Date等。</li>
<li>这些统称为引用类型，在声明一个引用类型的时候，将实例化对象地址存到栈内存中，然后通过地址访问堆内存。js中，函数的参数都是值传递的，而对于js内的引用类型，其值，也就默认为栈内存中的地址。(注意传值和传引用的区别)</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

    
    <div class="ds-share flat" data-thread-key="2016/08/25/dataType/" data-title="数据类型" data-images="/" data-content="success share" data-url="/">
        <div class="ds-share-inline">
          <ul  class="ds-share-icons-16" style="margin-top: 30px">
            
            
            <li><span>分享到：</span></li>
            <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
            <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
            <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
            <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
            <li> <a class="ds-facebook flat" href="javascript:void(0);" data-service="facebook">Facebook</a> </li>
            <li> <a class="ds-twitter flat" href="javascript:void(0);" data-service="twitter">Twitter</a> </li>
            
          </ul>
          
        </div>
     </div>

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
    	
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/19/render/" itemprop="url">
                  浏览器渲染过程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-08-19T14:03:44+08:00" content="2016-08-19">
              2016-08-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/js基础/" itemprop="url" rel="index">
                    <span itemprop="name">js基础</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/js基础/面经/" itemprop="url" rel="index">
                    <span itemprop="name">面经</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/19/render/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/19/render/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>面试常常被问到的一个问题就是，从输入网址到出现页面的过程。在这个过程里，就前端而言，最重要的部分就是渲染。那么不同浏览器使用的渲染引擎是不一样的，不同渲染引擎的渲染过程也会有一定差异，但大致过程是一致的。</p>
<p>Firefox, Safari两种浏览器构建于两种渲染引擎之上：</p>
<pre><code>1. Firefox使用Gecko——Mozilla自家的渲染引擎。  
2. Safari和 Chrome 都使用Webkit。
</code></pre><p>渲染的主要流程如下：</p>
<p>解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</p>
<ol>
<li>计算CSS样式</li>
<li>构建Render Tree</li>
<li>Layout – 定位坐标和大小，是否换行，各种position, overflow, z-index属性 ……</li>
<li>正式开画</li>
</ol>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>首先，浏览器会解析三个东西：</p>
<ol>
<li>HTML/SVG/XHTML，生成<strong>DOM Tree</strong>；</li>
<li>CSS，产生规则树，<strong>CSS Rule Tree</strong>；</li>
<li>JS，通过DOM API和CSSOM API操作DOM Tree和CSS Rule Tree。</li>
</ol>
<h4 id="DOM解析"><a href="#DOM解析" class="headerlink" title="DOM解析"></a>DOM解析</h4><p>一个常规的HTML会有html、head、title、body、div等标签，将它们解析会生成DOM Tree，由dom元素及属性节点组成，树的根是document对象。解析出的DOM Tree是下图的样子：</p>
<p><img src="http://o9j22gj41.bkt.clouddn.com/20160819_study_render_DOMTree.png" alt="DOM-Tree"></p>
<h4 id="CSS解析"><a href="#CSS解析" class="headerlink" title="CSS解析"></a>CSS解析</h4><p>CSS解析将css文件解析为样式表对象,每个对象包含css规则，css规则对象包含选择器和声明对象，以及其他一些符合css语法的对象。Webkit使用Flex和Bison解析生成器从CSS语法文件中自动生成解析器。Bison创建一个自底向上的解析器，Firefox使用自顶向下解析器。</p>
<h5 id="Webkit"><a href="#Webkit" class="headerlink" title="Webkit"></a>Webkit</h5><p>Webkit解析CSS如下图：</p>
<p><img src="http://o9j22gj41.bkt.clouddn.com/20160819_study_render_WebkitCSSTree.png" alt="Webkit-CSS-Tree"></p>
<h5 id="Firefox"><a href="#Firefox" class="headerlink" title="Firefox"></a>Firefox</h5><p>Firefox解析CSS的过程是，比照着DOM Tree和CSS Rule Tree，得到一个叫Style Context Tree。</p>
<pre><code>注意：

CSS匹配DOM Tree主要是从右到左解析CSS的Selector。CSS匹配HTML元素是一个相当复杂和有性能问题的事情。

所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。
</code></pre><p>Style Context Tree如下图。</p>
<p><img src="http://o9j22gj41.bkt.clouddn.com/20160819_study_render_FirefoxCSSTree.png" alt="Firefox-CSS-Tree"></p>
<h3 id="构造Rendering-Tree"><a href="#构造Rendering-Tree" class="headerlink" title="构造Rendering Tree"></a>构造Rendering Tree</h3><p>在解析完成以后，浏览器引擎会通过DOM Tree和CSS Rule Tree，构造Rendering Tree。</p>
<p>Firefox基本上来说是通过CSS解析生成CSS Rule Tree，然后，通过比对DOM Tree生成Style Context Tree，之后把Style Context Tree和Render Tree（Frame Tree）关联上，就完成了。</p>
<pre><code>注意：

1. Rendering Tree 渲染树并不等同于DOM树，因为一些像Header或display:none的东西就没必要放在渲染树中了；

2. CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element，也就是DOM结点。也就是所谓的Frame；

3. 计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程
</code></pre><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>最后，根据定位，调用操作系统的Native GUI的API可以绘制页面。</p>
<h3 id="Reflow和Repaint"><a href="#Reflow和Repaint" class="headerlink" title="Reflow和Repaint"></a>Reflow和Repaint</h3><p>渲染过程有两个重要概念，<strong>Reflow</strong>和<strong>Repaint</strong>。</p>
<ol>
<li>Repaint：屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。  </li>
<li><p>Reflow(Layout)：元件的几何尺寸变了，我们需要重新验证并计算Render Tree。Render Tree的一部分或全部发生了变化。</p>
<p> (1) HTML使用的是flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局(reflow)。  </p>
<p> (2) reflow 会从<html>这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在reflow过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。</html></p>
</li>
</ol>
<p>所以，Reflow的成本比Repaint的成本高得多的多。</p>
<h4 id="增加成本的动作："><a href="#增加成本的动作：" class="headerlink" title="增加成本的动作："></a>增加成本的动作：</h4><ol>
<li>增加、删除、修改DOM结点时，会导致Reflow或Repaint；  </li>
<li>移动DOM的位置，或是做一个动画的时候；  </li>
<li>修改CSS样式的时候；  </li>
<li>Resize窗口（移动端没有这个问题），或是滚动的时候；  </li>
<li>修改网页的默认字体时。</li>
</ol>
<p>需要注意的是</p>
<pre><code>注意：

display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。
</code></pre><h4 id="reflow原因："><a href="#reflow原因：" class="headerlink" title="reflow原因："></a>reflow原因：</h4><ol>
<li>Initial。网页初始化的时候。</li>
<li>Incremental。一些Javascript在操作DOM Tree时。</li>
<li>Resize。其些元件的尺寸变了。</li>
<li>StyleChange。如果CSS的属性发生变化了。</li>
<li>Dirty。几个Incremental的reflow发生在同一个frame的子树上。</li>
</ol>
<h3 id="减少reflow-repaint"><a href="#减少reflow-repaint" class="headerlink" title="减少reflow/repaint"></a>减少reflow/repaint</h3><ol>
<li>不要一条一条地修改DOM的样式。与其这样，还不如预先定义好css的class，然后修改DOM的className。</li>
<li>把DOM离线后修改。<br> (1) 使用documentFragment对象在内存里操作DOM。<br> (2) 先把DOM给display:none(有一次reflow)，然后再做修改。比如修改100次，然后再把他显示出来。<br> (3) clone一个DOM结点到内存里，再做修改，改完以后，和在线的那个的交换一下。   </li>
<li>不要把DOM结点的属性值放在一个循环里当成循环里的变量，不然这会导致大量地读写这个结点的属性。    </li>
<li>尽可能的修改层级比较低的DOM。<br> 改变层级比较底的DOM有可能会造成大面积的reflow，但是也可能影响范围很小。</li>
<li>为动画的HTML元件使用fixed或absoult的position，那么修改他们的CSS是不会reflow的。  </li>
<li>千万不要使用table布局。因为可能很小的一个小改动会造成整个table的重新布局。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

    
    <div class="ds-share flat" data-thread-key="2016/08/19/render/" data-title="浏览器渲染过程" data-images="/" data-content="success share" data-url="/">
        <div class="ds-share-inline">
          <ul  class="ds-share-icons-16" style="margin-top: 30px">
            
            
            <li><span>分享到：</span></li>
            <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
            <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
            <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
            <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
            <li> <a class="ds-facebook flat" href="javascript:void(0);" data-service="facebook">Facebook</a> </li>
            <li> <a class="ds-twitter flat" href="javascript:void(0);" data-service="twitter">Twitter</a> </li>
            
          </ul>
          
        </div>
     </div>

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
    	
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/09/Closures/" itemprop="url">
                  闭包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-08-09T14:21:08+08:00" content="2016-08-09">
              2016-08-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/js基础/" itemprop="url" rel="index">
                    <span itemprop="name">js基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/08/09/Closures/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/08/09/Closures/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先是闭包的概念，闭包是指有权访问另一个函数作用域中的变量的函数。</p>
<p>常见的创建闭包的方式，就是在一个函数里创建另一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparison</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> value1 = object1(propertyName); <span class="comment">// 访问了外部变量propertyName</span></div><div class="line">		<span class="keyword">var</span> value2 = object2(propertyName); <span class="comment">// 访问了外部变量propertyName</span></div><div class="line"></div><div class="line">		<span class="keyword">if</span>(value1 &lt; value2) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2) &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>即使内部函数被返回了，而且在其他地方被调用，依然可以访问变量propertyName，这涉及到作用域链相关知识。</p>
<h4 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h4><p>作用域链会引起一个副作用，就是闭包只能取得包含函数中任何变量的最后一个值，因为闭包保存的是整个变量对象，而不是特殊的变量。对比下面两段代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">		result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> i;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125; <span class="comment">// 每个函数都返回10。</span></div></pre></td></tr></table></figure>
<p>因为每个函数的作用域链都保存着createFunction()函数的活动对象，所以它们引用的都是同一个变量i，createFunction()返回以后i是10，所以以后的值都是10。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">createFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line"></div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) &#123;</div><div class="line">			result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</div><div class="line">				<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">					<span class="keyword">return</span> num;</div><div class="line">				&#125;;</div><div class="line">			&#125;(i); <span class="comment">// 定义匿名函数并立即执行</span></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">&#125; <span class="comment">// 每个函数返回各自不同的索引值。</span></div></pre></td></tr></table></figure>
<p>匿名函数有一个参数num，就是最终的函数要返回的值，在调用每个匿名函数的时候，传入变量i，因为函数参数是按值传递的，所以i的当前值就会复制给num，然后又创建并返回一个num的闭包。这样，result数组里的每个函数都有num变量的副本，就会返回各自不同的值。</p>
<h4 id="关于this对象"><a href="#关于this对象" class="headerlink" title="关于this对象"></a>关于this对象</h4><p>在全局函数中，this等于window，而当函数被作为某个对象的方法调用的时候，this就等于那个对象。但是，匿名函数的执行环境具有全局性，所以匿名函数this通常指向window。对比下面两段代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">	name: <span class="string">"My object"</span>,</div><div class="line"></div><div class="line">	getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()()); <span class="comment">// "window"(在非严格模式下)</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"window"</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">	name: <span class="string">"My object"</span>,</div><div class="line"></div><div class="line">	getNameFunc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 把外部作用域中的this保存在一个闭包能访问的变量里</span></div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> that.name; <span class="comment">// that引用的是object</span></div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">alert(object.getNameFunc()()); <span class="comment">// "My object"</span></div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

    
    <div class="ds-share flat" data-thread-key="2016/08/09/Closures/" data-title="闭包" data-images="/" data-content="success share" data-url="/">
        <div class="ds-share-inline">
          <ul  class="ds-share-icons-16" style="margin-top: 30px">
            
            
            <li><span>分享到：</span></li>
            <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
            <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
            <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
            <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
            <li> <a class="ds-facebook flat" href="javascript:void(0);" data-service="facebook">Facebook</a> </li>
            <li> <a class="ds-twitter flat" href="javascript:void(0);" data-service="twitter">Twitter</a> </li>
            
          </ul>
          
        </div>
     </div>

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
    	
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/20/inheritance/" itemprop="url">
                  继承
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-07-20T15:03:08+08:00" content="2016-07-20">
              2016-07-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/js基础/" itemprop="url" rel="index">
                    <span itemprop="name">js基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/20/inheritance/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/20/inheritance/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JS高程中介绍了很多继承方式。一般语言都支持两种继承方式：接口继承和实现继承，接口继承只继承方法签名，实现继承则继承实际的方法。因为函数没有签名，所以ES主要依靠<strong>原型链</strong>完成实现继承。</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>原型链中，包含引用类型值的原型属性，会被所有实例共享。而且在创建子类实例时，不能向超类型的构造函数中传递参数。所以一般不会单独使用原型链实现继承。</p>
<p>实现原型链有一个基本模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 继承了SuperType</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.getSuperValue()); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>通过创建SuperType的实例，把实例赋值给SubType.prototype实现SubType继承了SuperType，实现本质就是重写原型对象。实例、构造函数、原型对象之间的关系如下图。</p>
<p><img src="http://o9j22gj41.bkt.clouddn.com/inheritance-1-1.png" alt="instance-function-prototypr"></p>
<p>instance指向SubType的原型，SubType的原型指向SuperType的原型。instance.constructor现在指向的是SuperType，因为原来的SubType.prototype被重写了。</p>
<p>上例中调用instance.getSuperValue()会经历三个搜索步骤：<br>(1) 实例<br>(2) SubType.prototype<br>(3) SuperType.prototype</p>
<h4 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h4><p>所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。完整原型链如下图。</p>
<p><img src="http://o9j22gj41.bkt.clouddn.com/inheritance-1-2.png" alt="instance-function-prototype"></p>
<p>SubType继承了SuperType，SuperType继承了Object。当调用instance.toString()时，实际上是调用了Object.prototype中的方法。</p>
<h4 id="原型和实例的关系"><a href="#原型和实例的关系" class="headerlink" title="原型和实例的关系"></a>原型和实例的关系</h4><p>有两种方法可以确定原型和实例的关系：</p>
<blockquote>
<ul>
<li>instanceof操作符 (instance instanceof SuperType)</li>
<li>isPrototypeOf()方法 (SuperType.prototype.isPrototypeOf(instance))</li>
</ul>
</blockquote>
<h4 id="给原型添加方法"><a href="#给原型添加方法" class="headerlink" title="给原型添加方法"></a>给原型添加方法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//继承了SuperType</span></div><div class="line">SubType.property = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line"><span class="comment">//添加新方法</span></div><div class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//重写超类型中的方法</span></div><div class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.getSuperValue()); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>必须在用SuperType的实例替换原型之后，再定义新方法。通过原型链继承时，不能使用对象字面量创建原型方法，会重写原型链，原型被替换成字面量，变成一个Object实例，不再是SuperType实例，导致原型链被切断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//继承了SuperType</span></div><div class="line">SubType.property = <span class="keyword">new</span> SuperType();</div><div class="line"></div><div class="line"><span class="comment">//使用字面量添加新方法，导致上一行代码无效</span></div><div class="line">SubType.prototype = &#123;</div><div class="line">	getSubValue : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	someOtherMethod : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//重写超类型中的方法</span></div><div class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.getSuperValue()); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>基本思想就是，在子类型的构造函数中调用超类型构造函数。用这种方法就存在构造函数模式的问题，在构造函数里定义的方法，无法复用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="comment">//继承了SuperType,"借调"了超类型的构造函数</span></div><div class="line">	SuperType.call(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">// "red,blue,green,black"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance2.colors); <span class="comment">// "red,blue,green"</span></div></pre></td></tr></table></figure>
<p>通过使用call()方法，在新创建的SubType实例的环境下调用了SuperType构造函数，这样就可以在新SubType对象上执行SuperType()函数里定义的所有对象初始化代码(this.colors)，SubType的每个实例都会有自己的colors属性的<strong>副本</strong>了。  </p>
<p>相对于原型链，构造函数的一个优势就是，可以在子类构造函数中向超类构造函数<strong>传递参数</strong>。  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="comment">// 继承了SuperType，同时还传递了参数</span></div><div class="line">	SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</div><div class="line"></div><div class="line">	<span class="comment">// 实例属性</span></div><div class="line">	<span class="keyword">this</span>.age = <span class="number">29</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</div><div class="line">alert(instance.name); <span class="comment">// "Nicholas"</span></div><div class="line">alert(instance.age); <span class="comment">// 29</span></div></pre></td></tr></table></figure>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>将原型链和借用构造函数组合在一起，就是组合继承。基本思想：使用原型链实现对原型属性和方法的继承，然后通过构造函数来实现实例属性的继承。这样就可以实现函数复用，每个实例也能有自己的属性。  </p>
<p>组合继承也存在问题，会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</div><div class="line">	<span class="comment">// 继承属性</span></div><div class="line">	SuperType.call(<span class="keyword">this</span>, name); <span class="comment">// 第二次调用SuperType()</span></div><div class="line"></div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 继承方法</span></div><div class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">// 第一次调用SuperType()</span></div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</div><div class="line">instance1.colors.push(<span class="string">"black"</span>);</div><div class="line">alert(instance1.colors); <span class="comment">// "red,blue,green,black"</span></div><div class="line">instance1.sayName(); <span class="comment">// "Nicholas"</span></div><div class="line">instance1.sayAge(); <span class="comment">// 29</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</div><div class="line">alert(instance12.colors); <span class="comment">// "red,blue,green"</span></div><div class="line">instance2.sayName(); <span class="comment">// "Greg"</span></div><div class="line">instance2.sayAge(); <span class="comment">// 27</span></div></pre></td></tr></table></figure>
<ol>
<li>SuperType定义了两个属性：name、colors，SuperType的原型定义了一个方法sayName()。</li>
<li>SubType调用SuperType构造函数的时候传入参数name，又定义了自己的属性age。</li>
<li>SuperType的实例赋值给SubType的原型，在这个原型上定义方法sayAge()。</li>
</ol>
<p>这样就实现了两个不同的SubType实例分别有自己的属性，又拥有相同的方法。instanceof和isPrototypeOf()可以识别基于组合继承创建的对象。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>基本思想：借助原型可以基于已有的对象创建新对象，同事不需要创建自定义类型。ES5新增Object.create()方法规范了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和一个为新对象定义额外属性的对象(可选)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">	name: <span class="string">"Nicholas"</span>,</div><div class="line">	friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson1 = <span class="built_in">Object</span>.create(person);</div><div class="line">anotherPerson1.name = <span class="string">"Greg"</span>;</div><div class="line">anotherPerson1.friends.push(<span class="string">"Rob"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson2 = <span class="built_in">Object</span>.create(person);</div><div class="line">anotherPerson2.name = <span class="string">"Lily"</span>;</div><div class="line">anotherPerson2.friends.push(<span class="string">"Barbie"</span>);</div><div class="line"></div><div class="line">alert(person.friends); <span class="comment">// "Shelby,Court,Van,Rob,Barbie"</span></div></pre></td></tr></table></figure>
<p>Object.create()方法的第二个参数格式是，每个属性通过自己的描述符定义。这种方式指定的属性会覆盖原型对象上的同名属性。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">	name: <span class="string">"Nicholas"</span>,</div><div class="line">	friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</div><div class="line">	name: &#123;</div><div class="line">		value: <span class="string">"Greg"</span></div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">alert(anotherPerson.name); <span class="comment">// "Greg"</span></div></pre></td></tr></table></figure>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>基本思想：创建一个只用来封装继承过程的函数，在函数内部以某种方式来增强对象，然后像真的做了所有工作一样返回对象。这种模式跟构造函数模式类似，不能函数复用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">original</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> clone = <span class="built_in">Object</span>(original); <span class="comment">// 通过调用函数创建一个新对象</span></div><div class="line">	clone.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 以某种方式增强这个对象</span></div><div class="line">		alert(<span class="string">"hi"</span>); </div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> clone; <span class="comment">// 返回这个对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">	name: <span class="string">"Nicholas"</span>,</div><div class="line">	friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi(); <span class="comment">// "his"</span></div></pre></td></tr></table></figure>
<ol>
<li>createAnother接收了一个参数，作为新对象基础的对象。</li>
<li>把这个对象传递给object()函数，将返回结果赋值给clone。</li>
<li>再给clone对象添加一个新方法sayHi()。</li>
<li>返回clone对象。</li>
</ol>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>基本思想：本质上，就是使用寄生式继承超类型的原型，然后再将结果指定给子类型的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType， superType</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> prototype = <span class="built_in">Object</span>(superType.prototype); <span class="comment">// 创建对象</span></div><div class="line">	prototype.constructor = subType; <span class="comment">// 创建对象</span></div><div class="line">	subType.prototype = prototype; <span class="comment">// 创建对象</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">	SuperType.call(<span class="keyword">this</span>, name);</div><div class="line"></div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(SubType, SuperType);</div><div class="line"></div><div class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.age);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注：YUI的YAHOO.lang.extend()方法采用了寄生组合继承。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

    
    <div class="ds-share flat" data-thread-key="2016/07/20/inheritance/" data-title="继承" data-images="/" data-content="success share" data-url="/">
        <div class="ds-share-inline">
          <ul  class="ds-share-icons-16" style="margin-top: 30px">
            
            
            <li><span>分享到：</span></li>
            <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
            <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
            <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
            <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
            <li> <a class="ds-facebook flat" href="javascript:void(0);" data-service="facebook">Facebook</a> </li>
            <li> <a class="ds-twitter flat" href="javascript:void(0);" data-service="twitter">Twitter</a> </li>
            
          </ul>
          
        </div>
     </div>

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
    	
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/15/createObject/" itemprop="url">
                  创建对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">發表於</span>
            <time itemprop="dateCreated" datetime="2016-07-15T10:57:52+08:00" content="2016-07-15">
              2016-07-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分類於</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/js基础/" itemprop="url" rel="index">
                    <span itemprop="name">js基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/15/createObject/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/15/createObject/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JS高程中介绍的几种创建对象的模式。</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>这种模式抽象了创建具体对象的过程，用函数来封装以特定接口创建对象的细节。<br>解决了ES无法创建类的问题，可以创建多个相似对象，但是无法识别对象，无法判断一个对象的类型。工厂模式例子如下： </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">	o.name = name;</div><div class="line">	o.age = age;</div><div class="line">	o.job = job;</div><div class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<p>可以无数次调用createPerson函数，函数会根据接收的参数创建Person对象，并返回这个对象。  </p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><p>构造函数可以用来创建特定类型的函数，<strong>构造函数以大写字母开头，非构造函数以小写字母开头</strong>。<br>可以创建自定义的构造函数，从而定义自定义的对象类型的属性和方法。创建自定义的构造函数意味着以后<em>可以将它的实例标识为一种特定的类型</em>。<br>使用构造函数模式的主要问题是，每个方法都要在每个实例上重新创建一次。<br>将上面的例子用构造函数模式重写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">	<span class="keyword">this</span>.job = job;</div><div class="line">	<span class="keyword">this</span>,sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure>
<p>上两段代码不同之处：  </p>
<blockquote>
<ul>
<li>没有显示的创建对象</li>
<li>直接将属性和方法附给了 this </li>
<li>没有 return </li>
</ul>
</blockquote>
<p>构造函数与普通函数的区别就是调用方式不同，构造函数使用 <strong>new</strong> 操作符。上面定义的 Person() 函数可以用下面任意一种方式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 当做构造函数</span></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); <span class="comment">//典型用法，使用 new 操作符</span></div><div class="line">person.sayName(); <span class="comment">//"Nicholas"</span></div><div class="line"></div><div class="line"><span class="comment">// 当做普通函数 </span></div><div class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>); <span class="comment">// 添加到window</span></div><div class="line"><span class="built_in">window</span>.sayName(); <span class="comment">// "Greg"</span></div><div class="line"></div><div class="line"><span class="comment">// 在另一对象的作用域中调用</span></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">Person.call(o, <span class="string">"Kristen"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>);</div><div class="line">o.sayName(); <span class="comment">// "Kristen"</span></div></pre></td></tr></table></figure>
<p><strong>注</strong>：不同实例上的同名函数是不相等的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert( person1.sayName == person2.sayName ); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象，不需要再构造函数中定义对象实例的信息，而是可以将这些信息直接添加到到原型对象中。<strong>原型模式最大的问题在于，原型中所有属性是被很多实例共享的</strong>。</p>
<h4 id="例1-将信息直接添加到原型对象中"><a href="#例1-将信息直接添加到原型对象中" class="headerlink" title="例1 将信息直接添加到原型对象中"></a>例1 将信息直接添加到原型对象中</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line">person1.sayName(); <span class="comment">// "Nicholas"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person()</div><div class="line">person2.sayName(); <span class="comment">//"Nicholas"</span></div><div class="line"></div><div class="line">alert( person1.sayName == person2.sayName ); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>将sayName()方法和所有属性添加到Person的prototype属性，构造函数变成空函数。由构造函数创建新对象，新对象的属性和方法是由所有实例<strong>共享</strong>。  </p>
<h4 id="例2-实例属性屏蔽原型中同名属性"><a href="#例2-实例属性屏蔽原型中同名属性" class="headerlink" title="例2 实例属性屏蔽原型中同名属性"></a>例2 实例属性屏蔽原型中同名属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</div><div class="line">Person.prototype.age = <span class="number">29</span>;</div><div class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</div><div class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">person1.name = <span class="string">"Greg"</span>;</div><div class="line">alert(person1.name); <span class="comment">// "Greg" 来自实例</span></div><div class="line">alert(person2.name); <span class="comment">// "Nicholas" 来自原型</span></div></pre></td></tr></table></figure>
<p>给对象实例添加的属性会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为null，也只会在实例中设置这个属性，不会恢复其指向原型的连接。使用<strong>delete</strong>操作符可以完全删除实例属性。  </p>
<h4 id="例3-更简单的原型语法"><a href="#例3-更简单的原型语法" class="headerlink" title="例3 更简单的原型语法"></a>例3 更简单的原型语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">	name : <span class="string">"Nicholas"</span>,</div><div class="line">	age : <span class="number">29</span>,</div><div class="line">	job : <span class="string">"Software Engineer"</span>,</div><div class="line">	sayName : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>用包含所有属性和方法的<strong>对象字面量</strong>来重写原型对象，最终结果一样，但是constructor属性不在指向Person。所以需要指定constructor，确保通过该属性能访问到适当的值，指定以后会导致它的[[Enumerable]特性设置为 true ，变成可枚举。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">	<span class="keyword">constructor</span> : Person, // 指定<span class="keyword">constructor</span></div><div class="line">	name : "Nicholas",</div><div class="line">	age : 29,</div><div class="line">	job : "Software Engineer",</div><div class="line">	sayName : function()&#123;</div><div class="line">		alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="string">"hi"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">friend.sayHi(); <span class="comment">// "hi" (No Problem!)</span></div></pre></td></tr></table></figure>
<p>创建一个Person实例，保存在friend中。调用sayHi的时候，先搜索实例，然后再搜索原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">Person.prototype = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">constructor</span> : Person.</div><div class="line">	name : "Nicholas",</div><div class="line">	age : 29,</div><div class="line">	job : "Software Engineer",</div><div class="line">	sayName : function()&#123;</div><div class="line">		alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">friend.sayName(); <span class="comment">// error！</span></div></pre></td></tr></table></figure>
<p>出错是因为，friend指向的原型中不包含以这个名字命名的属性。已经创建实例的情况下，重写原型对象会切断现有实例与新原型之间的联系。</p>
<h3 id="组合构造函数模式-原型模式"><a href="#组合构造函数模式-原型模式" class="headerlink" title="组合构造函数模式+原型模式"></a>组合构造函数模式+原型模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">	<span class="keyword">this</span>.job = job;</div><div class="line">	<span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">	<span class="keyword">constructor</span> : Person,</div><div class="line">	sayName : function()&#123;</div><div class="line">		alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div><div class="line"></div><div class="line">person1.friends.push(<span class="string">"Van"</span>);</div><div class="line">alert(person1.friends);  <span class="comment">// "Shelby,Court,Van";</span></div><div class="line">alert(person2.friends);  <span class="comment">// "Shelby,Court"</span></div><div class="line">alert(person1.friends === person2.friends);  <span class="comment">// false</span></div><div class="line">alert(person1.sayName === person2.sayName);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>组合模式中，所有实例属性都写在构造函数中，所有的共享属性和方法在原型中定义。</p>
<p>另外还有以下几种创建对象的模式</p>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">//属性</span></div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">	<span class="keyword">this</span>.age = age;</div><div class="line">	<span class="keyword">this</span>.job = job;</div><div class="line"></div><div class="line">	<span class="comment">//方法</span></div><div class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</div><div class="line"></div><div class="line">		Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			alert(<span class="keyword">this</span>.name);</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure>
<p>这里只有在sayName不存在的情况下才会添加到原型中，if代码只有在初次调用构造函数的时候才会执行。使用这个方法时，<strong>不能使用</strong>对象字面量重写原型。</p>
<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">	o.name = name;</div><div class="line">	o.age = age;</div><div class="line">	o.job = job;</div><div class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建议不使用这种模式</p>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">// 创建要返回的对象</span></div><div class="line">	<span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">	</div><div class="line">	<span class="comment">// 可以在这里定义私有变量和函数</span></div><div class="line"></div><div class="line">	<span class="comment">//添加方法</span></div><div class="line">	o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		alert(<span class="keyword">this</span>.name);</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment">//返回对象</span></div><div class="line">	<span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

    
    <div class="ds-share flat" data-thread-key="2016/07/15/createObject/" data-title="创建对象" data-images="/" data-content="success share" data-url="/">
        <div class="ds-share-inline">
          <ul  class="ds-share-icons-16" style="margin-top: 30px">
            
            
            <li><span>分享到：</span></li>
            <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
            <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
            <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
            <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
            <li> <a class="ds-facebook flat" href="javascript:void(0);" data-service="facebook">Facebook</a> </li>
            <li> <a class="ds-twitter flat" href="javascript:void(0);" data-service="twitter">Twitter</a> </li>
            
          </ul>
          
        </div>
     </div>

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://o9j22gj41.bkt.clouddn.com/avatar.jpg"
               alt="MissAceQ" />
          <p class="site-author-name" itemprop="name">MissAceQ</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">11</span>
              <span class="site-state-item-name">文章</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分類</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">標籤</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MissAceQ</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 強力驅動
</div>

<div class="theme-info">
  主題 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
<div>
<span id="busuanzi_container_site_pv">
    本站总访问量<span id="busuanzi_value_site_pv"></span>次 &nbsp&nbsp&nbsp
    您是第<span id="busuanzi_value_site_uv"></span>个来到的小伙伴
</span>

</div>
        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"missaceq"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
